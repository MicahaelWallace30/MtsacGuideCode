#pragma config(Sensor, in1,    PotLift,        sensorPotentiometer)
#pragma config(Sensor, in2,    teamSelection,  sensorPotentiometer)
#pragma config(Sensor, in3,    SharpIR,        sensorAnalog)
#pragma config(Sensor, dgtl1,  EncoderDriveLeft, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  EncoderDriveRight, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  ButtonFront,    sensorTouch)
#pragma config(Sensor, dgtl6,  SonarFront,     sensorSONAR_inch)
#pragma config(Motor,  port2,           DriveLeft,     tmotorVex393, openLoop)
#pragma config(Motor,  port5,           Lift,          tmotorVex393, openLoop)
#pragma config(Motor,  port9,           DriveRight,    tmotorVex393, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Robot_Functions.h"



bool driveP(int minPower, int MaxPower, int steering, int distance, int const DEFAULT_TIME_OUT = DEFAULAT_TIME_OUT_MS);

int const MIN_POWER = 50;
int const MAX_POWER = 100;
int const DESIRED_DISTANCE = 300;
task main()
{
	driveP(MIN_POWER, MAX_POWER, 0, DESIRED_DISTANCE);
}

/*****************************************/
//function to drive distance
//check if timed out
//returns true if success
//false if failure
/*****************************************/
bool driveP(int minPower, int MaxPower, int steering, int distance,  int const DEFAULT_TIME_OUT)
{
	ClearTimer(T1);//clear timer to keep track of time to reach distance
	clearDriveEncoders();//clear both encoders
	while(abs(SensorValue(EncoderDriveLeft)) < distance && abs(SensorValue(EncoderDriveRight)) < distance)//make sure both sides have reach the proper distance
	{
		//error will loop from infinity to 0 to infinity again, but while loop should stop drive when error is around 0
		int error = distance - (abs(SensorValue(EncoderDriveLeft)) + abs(SensorValue(EncoderDriveRight)))/2;
		int power = minPower + error;
		if(power > MaxPower) power = MaxPower;

		drive(power, steering);
		if(time1[T1] > DEFAULT_TIME_OUT)//check if robot has take too long to reach distance
		{
			drive(0,0);//stop drive
			return false;//destination failed timed out return false
		}
	}

	drive(0,0);//stop drive
	return true;//distance success return true
}
